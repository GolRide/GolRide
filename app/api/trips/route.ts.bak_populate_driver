import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import { Trip } from "@/models/Trip";
import { requireSession } from "@/lib/auth";

// GET /api/trips  -> lista viajes (para /trips y búsquedas)
export async function GET(req: Request) {
  try {
    await dbConnect();

    const { searchParams } = new URL(req.url);

    const origin = (searchParams.get("origin") || "").trim();
    const destination = (searchParams.get("destination") || "").trim();
    const team = (searchParams.get("team") || "").trim();
    const date = (searchParams.get("date") || "").trim();

    // Base: solo activos
    const query: any = { active: true };

    // ✅ filtros estrictos (si vienen, se aplican)
    if (origin) query.origin = { $regex: origin, $options: "i" };
    if (destination) query.destination = { $regex: destination, $options: "i" };

    // ✅ date=YYYY-MM-DD -> ventana: día anterior, mismo día y día siguiente
    if (date) {
      const d = new Date(date);
      // Ventana [-1, +1] días (00:00 del día anterior -> 23:59:59 del día siguiente)
      const from = new Date(d);
      from.setDate(from.getDate() - 1);
      from.setHours(0, 0, 0, 0);

      const to = new Date(d);
      to.setDate(to.getDate() + 1);
      to.setHours(23, 59, 59, 999);

      query.date = { $gte: from, $lte: to };
    }

    // ✅ team flexible: busca en team o match
    if (team) {
      query.$or = [
        { team: { $regex: team, $options: "i" } },
        { match: { $regex: team, $options: "i" } },
      ];
    }

    const trips = await Trip.find(query)
      .sort({ date: 1, time: 1, createdAt: -1 })
      .limit(200)
      .lean();

    return NextResponse.json({ ok: true, trips }, { status: 200 });
  } catch (e: any) {
    console.error("GET /api/trips error:", e);
    return NextResponse.json(
      { ok: false, error: e?.message ?? "Error listando viajes" },
      { status: 500 }
    );
  }
}

// POST /api/trips -> crea viaje (protegido)
function getUserId(session: any): string | null {
  return (
    session?.user?.id ||
    session?.user?._id ||
    session?.userId ||
    session?.id ||
    null
  );
}

export async function POST(req: Request) {
  try {
    await dbConnect();

    const session = await requireSession();
    const userId = getUserId(session);

    if (!userId) {
      return NextResponse.json({ ok: false, error: "UNAUTHENTICATED" }, { status: 401 });
    }

    const body = await req.json();
    const seatsTotal = Number(body.seatsTotal ?? 0);
    const clientRequestId = body?.clientRequestId ? String(body.clientRequestId) : null;

    const doc = {
      ...body,
      creatorId: userId,
      seatsAvailable: body.seatsAvailable ?? seatsTotal,
      meetingPoint: body.meetingPoint ?? "",
      clientRequestId,
    };

    // ✅ idempotencia robusta
    if (clientRequestId) {
      try {
        const trip = await Trip.create(doc);
        return NextResponse.json({ ok: true, id: String(trip._id), trip, duplicated: false }, { status: 201 });
      } catch (e: any) {
        // Si entran 2 POST casi a la vez con el mismo clientRequestId, el índice único salta
        if (String(e?.code) === "11000") {
          const existing = await Trip.findOne({ creatorId: userId, clientRequestId }).lean();
          if (existing) {
            return NextResponse.json(
              { ok: true, id: String(existing._id), trip: existing, duplicated: true },
              { status: 200 }
            );
          }
        }
        throw e;
      }
    }

    // Si no viene clientRequestId, comportamiento normal
    const trip = await Trip.create(doc);
    return NextResponse.json({ ok: true, id: String(trip._id), trip }, { status: 201 });
  } catch (e: any) {
    console.error("POST /api/trips error:", e);
    return NextResponse.json(
      { ok: false, error: e?.message ?? "Error creando viaje" },
      { status: 500 }
    );
  }
}
